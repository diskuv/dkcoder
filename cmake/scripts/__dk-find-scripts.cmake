##########################################################################
# File: dktool/cmake/scripts/__dk-find-scripts.cmake                     #
#                                                                        #
# Copyright 2023 Diskuv, Inc.                                            #
#                                                                        #
# Licensed under the Open Software License version 3.0                   #
# (the "License"); you may not use this file except in compliance        #
# with the License. You may obtain a copy of the License at              #
#                                                                        #
#     https://opensource.org/license/osl-3-0-php/                        #
#                                                                        #
##########################################################################

# Recommendation: Place this file in source control.
# Auto-generated by `./dk dkml.wrapper.upgrade` of dktool.

include(FetchContent)

# Map of DkCoder versions.
#   The SHA256 checksums are all available from
#   https://gitlab.com/diskuv/distributions/1.0/dksdk-coder/-/packages/21844308 (select
#   the right <COMPILE_VERSION> version of course)
set(__DkRun_V0_1_COMPILE_VERSION 0.1.0-1)
set(__DkRun_V0_1_URL_BASE https://gitlab.com/api/v4/projects/52918795/packages/generic/stdexport/${__DkRun_V0_1_COMPILE_VERSION})
set(__DkRun_V0_1_SHA256_windows_x86_64 0189dc5535813ddaa3a65e0016bcb3f426e7ef9ed7695c47a334f69311945e58)
set(__DkRun_V0_1_SHA256_windows_x86    d2f1d3caaee3464b4a8e1ffac4b58af979124ecb0bef5a0714f8556936698ea2)
set(__DkRun_V0_1_SHA256_linux_x86_64   5f4dec1eccd0a9cd4e03dca5e45bad987895102767c73c04920f03181f891a2f)
set(__DkRun_V0_1_SHA256_linux_x86      cf6f9a7e3cd98783cd42dff7a7aaed7199054be2acbf02174e237b676a71f516)
set(__DkRun_V0_1_SHA256_darwin_x86_64  todo_darwin_x86_64)
set(__DkRun_V0_1_SHA256_darwin_arm64   bf8bbf3b970212731c6464f6af005e29f30aa6bfbbf23b6f819d0965eff6f1d4)
set(__DkRun_V0_1_EOL "2024-09-30")
#   `Env` is a valid DkCoder version if $DKRUN_ENV_URL_BASE exists. Typically it is a file:// URL.
set(__DkRun_Env_URL_BASE)
if(DEFINED ENV{DKRUN_ENV_URL_BASE})
    set(__DkRun_Env_COMPILE_VERSION Env)
    set(__DkRun_Env_URL_BASE "$ENV{DKRUN_ENV_URL_BASE}")
    string(TIMESTAMP __DkRun_Env_EOL "%Y-%m-%d" UTC)
endif()
#   Once a version is supported in [__DkRun_LTS_VERSIONS] it should be supported until _EOL.
#   The last LTS version is what ./dk uses by default, so keep this chronologically sorted
#   by oldest to newest.
set(__DkRun_LTS_VERSIONS "V0_1")

# ocamlc.exe, ocamlrun.exe, ocamldep.exe, dune.exe, dkcoder.exe all are compiled with
# Visual Studio on Windows. That means they need the redistributable installed.
# https://learn.microsoft.com/en-us/cpp/windows/latest-supported-vc-redist?view=msvc-170
function(__dkcoder_install_vc_redist)
    set(noValues)
    set(singleValues LOGLEVEL)
    set(multiValues)
    cmake_parse_arguments(PARSE_ARGV 0 ARG "${noValues}" "${singleValues}" "${multiValues}")

    # Default LOGLEVEL
    if(NOT ARG_LOGLEVEL)
        set(ARG_LOGLEVEL "STATUS")
    endif()

    # On Windows CMAKE_HOST_SYSTEM_PROCESSOR = ENV:PROCESSOR_ARCHITECTURE
    # Values: AMD64, IA64, ARM64, x86
    # https://docs.microsoft.com/en-us/windows/win32/winprog64/wow64-implementation-details?redirectedfrom=MSDN#environment-variables
    if(CMAKE_HOST_SYSTEM_PROCESSOR STREQUAL x86 OR CMAKE_HOST_SYSTEM_PROCESSOR STREQUAL X86)
        set(vcarch x86)
    elseif(CMAKE_HOST_SYSTEM_PROCESSOR STREQUAL arm64 OR CMAKE_HOST_SYSTEM_PROCESSOR STREQUAL ARM64)
        set(vcarch arm64)
    else()
        set(vcarch x64)
    endif()

    # Do we need to install?
    if(CMAKE_VERSION VERSION_GREATER_EQUAL 3.24)
        # The "correct" way is to check through
        # reg query HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\VisualStudio\14.0\VC\Runtimes\x64 /V Version
        # (etc.) if there is a newer version. Confer
        # https://learn.microsoft.com/en-us/cpp/windows/redistributing-visual-cpp-files?view=msvc-170#install-the-redistributable-packages
        cmake_host_system_information(RESULT result
            QUERY WINDOWS_REGISTRY "HKLM/SOFTWARE/Microsoft/VisualStudio/14.0/VC/Runtimes/${vcarch}"
            VALUE Version)
        #   v14.38.33135.00 -> 14.38.33135.00
        string(REGEX REPLACE "^v" "" result "${result}")
        if(result VERSION_GREATER_EQUAL 14.38.33135.00) # Future? Embed version number inside DkCoder file tree.
            message(${ARG_LOGLEVEL} "Re-using Visual C++ Redistributable v${result}")
            return()
        endif()
    endif()

    set(url "https://aka.ms/vs/17/release/vc_redist.${vcarch}.exe")
    message(${ARG_LOGLEVEL} "Downloading Visual C++ Redistributable from ${url}")
    file(DOWNLOAD ${url} ${CMAKE_CURRENT_BINARY_DIR}/vc_redist.exe)
    execute_process(
        # https://github.com/aaronparker/vcredist/blob/main/VcRedist/VisualCRedistributables.json
        COMMAND ${CMAKE_CURRENT_BINARY_DIR}/vc_redist.exe /install /passive /norestart
        RESULT_VARIABLE vc_redist_errcode
    )
    if(vc_redist_errcode EQUAL 0)
        message(${ARG_LOGLEVEL} "Installed Visual C++ Redistributable.")
    elseif(vc_redist_errcode EQUAL 1638)
        # Allow exit code 1638 which is the code that a newer vcredist is already
        # installed. https://github.com/diskuv/dkml-installer-ocaml/issues/60
        message(${ARG_LOGLEVEL} "A newer Visual C++ Redistributable was already installed.")
    elseif(vc_redist_errcode EQUAL 3010)
        # https://github.com/ScoopInstaller/Extras/blob/master/bucket/vcredist2022.json#L22. Do nothing since /norestart.
        message(${ARG_LOGLEVEL} "Visual C++ Redistributable reports that your machine needs to be restarted.")
    else()
        message(FATAL_ERROR "Problem: Visual C++ Redistributable failed to install. Exit code ${vc_redist_errcode}\n\nSolution: Download and install the latest Visual C++ Redistributable for your hardware architecture at https://learn.microsoft.com/en-us/cpp/windows/latest-supported-vc-redist")
    endif()
endfunction()

function(__dkcoder_error_wrong_version problem_prefix)
    list(JOIN __DkRun_LTS_VERSIONS " " lts_versions)
    message(FATAL_ERROR "Problem: ${problem_prefix}The only long-term supported versions accepted by this script are: ${lts_versions}.\n\nSolution: Run `./dk dkml.wrapper.upgrade` in your Terminal without the backticks.")
endfunction()

function(__dkcoder_abi)
    set(noValues)
    set(singleValues ABI_VARIABLE)
    set(multiValues)
    cmake_parse_arguments(PARSE_ARGV 0 ARG "${noValues}" "${singleValues}" "${multiValues}")

    # Detect ABI (todo: cache it somewhere)
    set(solution "Solution: If you are a DkSDK subscriber and need a new platform, contact your DkSDK Support representative.")
    if(CMAKE_HOST_WIN32)
        # On Windows CMAKE_HOST_SYSTEM_PROCESSOR = ENV:PROCESSOR_ARCHITECTURE
        # Values: AMD64, IA64, ARM64, x86
        # https://docs.microsoft.com/en-us/windows/win32/winprog64/wow64-implementation-details?redirectedfrom=MSDN#environment-variables
        if(CMAKE_HOST_SYSTEM_PROCESSOR STREQUAL x86 OR CMAKE_HOST_SYSTEM_PROCESSOR STREQUAL X86)
            set(dkml_host_abi windows_x86)
        else()
            set(dkml_host_abi windows_x86_64)
        endif()
    elseif(CMAKE_HOST_APPLE)
        execute_process(COMMAND uname -m
                OUTPUT_VARIABLE host_machine_type
                OUTPUT_STRIP_TRAILING_WHITESPACE
                COMMAND_ERROR_IS_FATAL ANY)
        if(host_machine_type STREQUAL x86_64)
            set(dkml_host_abi darwin_x86_64)
        elseif(host_machine_type STREQUAL arm64)
            set(dkml_host_abi darwin_arm64)
        else()
            message(FATAL_ERROR "Problem: Unfortunately, your macOS ${host_machine_type} platform is currently not supported by this download script. ${solution}")
        endif()
    elseif(CMAKE_HOST_LINUX)
        execute_process(COMMAND uname -m
                OUTPUT_VARIABLE host_machine_type
                OUTPUT_STRIP_TRAILING_WHITESPACE
                COMMAND_ERROR_IS_FATAL ANY)
        if(host_machine_type STREQUAL x86_64)
            set(dkml_host_abi linux_x86_64)
        elseif(host_machine_type STREQUAL i686)
            set(dkml_host_abi linux_x86)
        else()
            message(FATAL_ERROR "Problem: Your Linux ${host_machine_type} platform is currently not supported by this download script. ${solution}")
        endif()
    else()
        message(FATAL_ERROR "Problem: DkCoder is only available on Windows, macOS and Linux. ${solution}")
    endif()

    set("${ARG_ABI_VARIABLE}" "${dkml_host_abi}" PARENT_SCOPE)
endfunction()

# Installs DkCoder project.
#
# Arguments:
#   VERSION
#   LOGLEVEL
# Read-only Filesystem Outputs: (never modify the files or mutate the directories. On macOS part of a Bundle)
# - DKCODER - location of the `dkcoder` executable
# - DKCODER_RUN - location of the `DkCoder_Edge-Run.bc` bytecode executable (here "Edge" means the latest version for the VERSION; aka. the VERSION itself)
# - DKCODER_HELPERS - location of bin directory or DkCoder.bundle/Contents/Helpers on macOS
# - DKCODER_ETC - location of etc/dkcoder directory
# - DKCODER_LIB - location of lib/ directory containing lib/ocaml/ and other libraries compatible with dkcoder
# - DKCODER_SHARE - location of share directory
# - DKCODER_OCAMLC - location of ocamlc compatible with dkcoder
# - DKCODER_OCAMLRUN - location of ocamlrun compatible with dkcoder
# - DKCODER_DUNE - location of dune compatible with dkcoder
function(__dkcoder_install)
    set(noValues)
    set(singleValues ABI VERSION LOGLEVEL)
    set(multiValues)
    cmake_parse_arguments(PARSE_ARGV 0 ARG "${noValues}" "${singleValues}" "${multiValues}")

    # Default LOGLEVEL
    if(NOT ARG_LOGLEVEL)
        set(ARG_LOGLEVEL "STATUS")
    endif()

    # Set the DkCoder home
    cmake_path(APPEND DKSDK_DATA_HOME coder h ${ARG_VERSION} OUTPUT_VARIABLE DKCODER_HOME)

    # Parse Major.Minor from VERSION
    if(ARG_VERSION MATCHES "^([0-9]+)[.]([0-9]+)[.]")
        set(version_major "${CMAKE_MATCH_1}")
        set(version_minor "${CMAKE_MATCH_2}")
        set(V_id "V${version_major}_${version_minor}")
    elseif(ARG_VERSION STREQUAL "Env")
        set(V_id "Env")
    else()
        # alert: do not expose unsanitized user-supplied data
        message(FATAL_ERROR "Problem: We expected a full DkCoder version like 0.1.0-2.\n\nSolution: DkSDK subscribers should contact their DkSDK Support representative.")
    endif()

    # Get from DkCoder version map
    set(url_base "${__DkRun_${V_id}_URL_BASE}")
    set(compile_version "${__DkRun_${V_id}_COMPILE_VERSION}")
    set(sha256_windows_x86_64   "${__DkRun_${V_id}_SHA256_windows_x86_64}")
    set(sha256_windows_x86      "${__DkRun_${V_id}_SHA256_windows_x86}")
    set(sha256_linux_x86_64     "${__DkRun_${V_id}_SHA256_linux_x86_64}")
    set(sha256_linux_x86        "${__DkRun_${V_id}_SHA256_linux_x86}")
    set(sha256_darwin_x86_64    "${__DkRun_${V_id}_SHA256_darwin_x86_64}")
    set(sha256_darwin_arm64     "${__DkRun_${V_id}_SHA256_darwin_arm64}")
    if(compile_version STREQUAL "Env")
        if(NOT url_base)
            __dkcoder_error_wrong_version("You were using the Env version of DkCoder. ")
        endif()
    elseif(NOT url_base OR NOT compile_version OR NOT sha256_windows_x86_64 OR NOT sha256_windows_x86
        OR NOT sha256_linux_x86_64 OR NOT sha256_linux_x86
        OR NOT sha256_darwin_x86_64 OR NOT sha256_darwin_arm64)
        __dkcoder_error_wrong_version("You were using DkCoder version ${V_id}. ")
    endif()

    # Make a work directory
    set(CMAKE_CURRENT_BINARY_DIR "${CMAKE_CURRENT_BINARY_DIR}/_dkcoder__${compile_version}")

    # Get the ABI
    set(dkml_host_abi "${ARG_ABI}")

    # Location where ocamlfind.conf should be
    set(ocamlfind_conf "${DKCODER_HOME}/findlib.conf")

    set(hints "${DKCODER_HOME}/DkCoder.bundle/Contents/Helpers" "${DKCODER_HOME}/bin")
    set(find_program_ARGS NO_DEFAULT_PATH)
    find_program(DKCODER NAMES dkcoder HINTS ${hints} ${find_program_ARGS})

    if(NOT DKCODER)
        # Download into ${DKCODER_HOME} (which is one of the HINTS)
        set(downloaded)

        # URL
        if(dkml_host_abi MATCHES "^windows_.*" OR dkml_host_abi MATCHES "^darwin_.*")
            set(out_exp .zip)
        else()
            set(out_exp .tar.gz)
        endif()
        set(url "${url_base}/stdexport-${dkml_host_abi}${out_exp}")

        # Checksum? Always do it unless we are using the Env version
        set(expected_hash_ARGS)
        if(compile_version STREQUAL "Env")
            message(${ARG_LOGLEVEL} "Downloading DkCoder locally from ${url}")
        else()
            set(expected_hash_ARGS EXPECTED_HASH "SHA256=${sha256_${dkml_host_abi}}")
            message(${ARG_LOGLEVEL} "Downloading and sha256 validating DkCoder from ${url}")
        endif()

        # Download
        if(url MATCHES "^file://(.*)")
            set(download_DEST "${CMAKE_MATCH_1}")
            set(download_REMOVE OFF)
        else()
            set(download_DEST "${CMAKE_CURRENT_BINARY_DIR}/stdexport${out_exp}")
            set(download_REMOVE ON)
            file(DOWNLOAD "${url}" "${download_DEST}" ${expected_hash_ARGS})
        endif()
        message(${ARG_LOGLEVEL} "Extracting DkCoder")
        file(ARCHIVE_EXTRACT INPUT "${download_DEST}"
            DESTINATION "${CMAKE_CURRENT_BINARY_DIR}/_e")

        # Install prereq: Visual C++ Redistributable
        if(CMAKE_HOST_WIN32)
            __dkcoder_install_vc_redist(LOGLEVEL ${ARG_LOGLEVEL})
        endif()

        # Install
        #   Do file(RENAME) but work across mount volumes (ex. inside containers)
        message(${ARG_LOGLEVEL} "Copying DkCoder to final install location")
        file(REMOVE_RECURSE "${DKCODER_HOME}")
        file(MAKE_DIRECTORY "${DKCODER_HOME}")
        file(GLOB entries
            LIST_DIRECTORIES true
            RELATIVE ${CMAKE_CURRENT_BINARY_DIR}/_e
            ${CMAKE_CURRENT_BINARY_DIR}/_e/*)
        foreach(entry IN LISTS entries)
            file(COPY ${CMAKE_CURRENT_BINARY_DIR}/_e/${entry}
                DESTINATION ${DKCODER_HOME}                
                USE_SOURCE_PERMISSIONS)
        endforeach()

        # Post-install: Configure findlib.conf to point to macOS bundle or Unix/Win32 extraction
        if(CMAKE_HOST_WIN32)
            # Windows needs entries like: destdir="C:\\TARBALL\\lib"
            cmake_path(NATIVE_PATH DKCODER_HOME DKCODER_HOME_NATIVE)
            string(REPLACE "\\" "\\\\" DKCODER_HOME_NATIVE_ESCAPED "${DKCODER_HOME_NATIVE}")

            file(CONFIGURE OUTPUT "${ocamlfind_conf}"
                CONTENT [[destdir="@DKCODER_HOME_NATIVE_ESCAPED@\\lib"
path="@DKCODER_HOME_NATIVE_ESCAPED@\\lib"]] @ONLY NEWLINE_STYLE UNIX)
        elseif(CMAKE_HOST_APPLE)
            file(CONFIGURE OUTPUT "${ocamlfind_conf}"
                CONTENT [[destdir="@DKCODER_HOME@/DkCoder.bundle/Contents/Resources/lib"
path="@DKCODER_HOME@/DkCoder.bundle/Contents/Resources/lib"]] @ONLY NEWLINE_STYLE UNIX)
        else()
            file(CONFIGURE OUTPUT "${ocamlfind_conf}"
                CONTENT [[destdir="@DKCODER_HOME@/lib"
path="@DKCODER_HOME@/lib"]] @ONLY NEWLINE_STYLE UNIX)
        endif()

        # Cleanup
        message(${ARG_LOGLEVEL} "Cleaning DkCoder intermediate files")
        file(REMOVE ${CMAKE_CURRENT_BINARY_DIR}/stdexport${out_exp})
        file(REMOVE_RECURSE "${CMAKE_CURRENT_BINARY_DIR}/_e")

        find_program(DKCODER NAMES dkcoder REQUIRED HINTS ${hints} ${find_program_ARGS})
        message(${ARG_LOGLEVEL} "DkCoder installed.")
    endif()

    cmake_path(GET DKCODER PARENT_PATH dkcoder_helpers)

    # macOS requires a code signing separation between executables (including shared libraries)
    # and non-executables (include bytecode). The latter will be in macOS bundle Resources/.
    if(CMAKE_HOST_APPLE)
        cmake_path(GET dkcoder_helpers PARENT_PATH dkcoder_resourcesdir)
        cmake_path(APPEND dkcoder_resourcesdir Resources)
    else()
        cmake_path(GET dkcoder_helpers PARENT_PATH dkcoder_resourcesdir)
    endif()

    # Export binaries.
    #   ocamlc, ocamlrun and dune must be in the same directory as dkcoder.
    find_program(DKCODER_OCAMLC NAMES ocamlc REQUIRED NO_DEFAULT_PATH HINTS ${dkcoder_helpers})
    find_program(DKCODER_OCAMLRUN NAMES ocamlrun REQUIRED NO_DEFAULT_PATH HINTS ${dkcoder_helpers})
    find_program(DKCODER_DUNE NAMES dune REQUIRED NO_DEFAULT_PATH HINTS ${dkcoder_helpers})
    find_program(DKCODER_RUN NAMES DkCoder_Edge-Run.bc REQUIRED NO_DEFAULT_PATH HINTS ${dkcoder_resourcesdir}/bytecode)

    set(problem_solution "Problem: The DkCoder installation is corrupted. Solution: Remove the directory ${DKCODER_HOME} and try again.")

    # Export ocamlfind.conf
    set(DKCODER_OCAMLFIND_CONF "${ocamlfind_conf}" PARENT_SCOPE)

    # Export bin/ or macOS bundle Helpers/
    if(NOT IS_DIRECTORY "${dkcoder_helpers}")
        message(FATAL_ERROR "${problem_solution}")
    endif()
    set(DKCODER_HELPERS "${dkcoder_helpers}" PARENT_SCOPE)

    # Export etc/dkcoder/ or macOS bundle Resources/etc/dkcoder
    cmake_path(APPEND dkcoder_resourcesdir etc dkcoder OUTPUT_VARIABLE dkcoder_etc)
    if(NOT IS_DIRECTORY "${dkcoder_etc}")
        message(FATAL_ERROR "${problem_solution}")
    endif()
    set(DKCODER_ETC "${dkcoder_etc}" PARENT_SCOPE)

    # Export lib
    cmake_path(APPEND dkcoder_resourcesdir lib OUTPUT_VARIABLE dkcoder_lib)
    if(NOT IS_DIRECTORY "${dkcoder_lib}")
        message(FATAL_ERROR "${problem_solution}")
    endif()
    set(DKCODER_LIB "${dkcoder_lib}" PARENT_SCOPE)

    # Export share
    cmake_path(APPEND dkcoder_resourcesdir share OUTPUT_VARIABLE dkcoder_share)
    if(NOT IS_DIRECTORY "${dkcoder_share}")
        message(FATAL_ERROR "${problem_solution}")
    endif()
    set(DKCODER_SHARE "${dkcoder_share}" PARENT_SCOPE)
endfunction()

macro(__dkcoder_prep_environment)
    set(envMods_UNIX)
    set(envMods_DOS)
    set(envMods_CMAKE)
endmacro()

function(__dkcoder_add_environment_mod term) # macros can't handle backslashes
    if(envMods_UNIX)
        string(APPEND envMods_UNIX " ")
        string(APPEND envMods_DOS " ")
    endif()
    string(APPEND envMods_DOS "--modify \"${term}\"")
    string(APPEND envMods_UNIX "--modify '${term}'")
    list(APPEND envMods_CMAKE --modify "${term}")

    set(envMods_DOS "${envMods_DOS}" PARENT_SCOPE)
    set(envMods_UNIX "${envMods_UNIX}" PARENT_SCOPE)
    set(envMods_CMAKE "${envMods_CMAKE}" PARENT_SCOPE)
endfunction()

function(__dkcoder_add_environment_set namevalue) # macros can't handle backslashes
    if(envMods_UNIX)
        string(APPEND envMods_UNIX " ")
        string(APPEND envMods_DOS " ")
    endif()
    string(APPEND envMods_DOS "\"${namevalue}\"")
    string(APPEND envMods_UNIX "'${namevalue}'")
    list(APPEND envMods_CMAKE "${namevalue}")

    set(envMods_DOS "${envMods_DOS}" PARENT_SCOPE)
    set(envMods_UNIX "${envMods_UNIX}" PARENT_SCOPE)
    set(envMods_CMAKE "${envMods_CMAKE}" PARENT_SCOPE)
endfunction()

# Delegate to DkCoder. We don't run inside CMake since CMake intercepts signals and (related?) makes
# Dune watch mode hang on Windows.
# Confer: https://stackoverflow.com/questions/75071180/pass-ctrlc-to-cmake-custom-command-under-vscode
function(__dkcoder_delegate)
    set(noValues)
    set(singleValues PACKAGE_NAMESPACE PACKAGE_QUALIFIER FULLY_QUALIFIED_MODULE ARGUMENT_LIST_VARIABLE)
    set(multiValues)
    cmake_parse_arguments(PARSE_ARGV 0 ARG "${noValues}" "${singleValues}" "${multiValues}")

    # Calculate environment variables
    #   Environment variables tested at dksdk-coder/ci/test-std-helper-dunebuild.sh.
    #   Since we have a rule that does [ocamlrun], which depends on
    #   compiling a bytecode executable, we have to do union of environments for
    #   both ocamlc + ocamlrun.
    __dkcoder_prep_environment()
    __dkcoder_add_environment_set("OCAMLLIB=${DKCODER_LIB}/ocaml")
    #   Assumptions.ocamlfind_configuration_available_to_ocaml_compiler_in_coder_run
    __dkcoder_add_environment_set("OCAMLFIND_CONF=${DKCODER_OCAMLFIND_CONF}")
    __dkcoder_add_environment_set("CDI_OUTPUT=${output_abspath}") # This environment variable is communication to `@gen-cdi` rule
    #   Assumptions.stublibs_are_available_to_ocaml_compiler_and_runtime_in_coder_run
    #       nit: Unclear why CAML_LD_LIBRARY_PATH is needed by Dune 3.12.1 when invoking [ocamlc] on Windows to get
    #       dllunix.dll (etc.), but it is. That is fine; we can do both PATH and CAML_LD_LIBRARY_PATH.
    if(CMAKE_HOST_APPLE)
        __dkcoder_add_environment_mod("CAML_LD_LIBRARY_PATH=path_list_prepend:${DKCODER_HELPERS}/stublibs")
        __dkcoder_add_environment_mod("PATH=path_list_prepend:${DKCODER_HELPERS}/stublibs")
    else()
        __dkcoder_add_environment_mod("CAML_LD_LIBRARY_PATH=path_list_prepend:${DKCODER_LIB}/stublibs")
        __dkcoder_add_environment_mod("CAML_LD_LIBRARY_PATH=path_list_prepend:${DKCODER_LIB}/ocaml/stublibs")
        __dkcoder_add_environment_mod("PATH=path_list_prepend:${DKCODER_LIB}/stublibs")
        __dkcoder_add_environment_mod("PATH=path_list_prepend:${DKCODER_LIB}/ocaml/stublibs")
    endif()
    #   Assumptions.coder_run_has_environment_for_compiling_bytecode
    #
    #   PATH=path_list_prepend? Assumptions.coder_compatible_dune_is_at_front_of_coder_run_path
    __dkcoder_add_environment_mod("PATH=path_list_prepend:${DKCODER_HELPERS}")

    # Propagate DKCODER_SHARE and DKCODER_HELPERS.
    #   Why not DKML_HOST_ABI? DkRun has a hardcoded default (so ABI hardcoding comes from the downloaded DkRun
    #   which is chosen by ./dk). But we don't change the default since a future DkRun may have a better
    #   detection of ABI (ex. ./dk downloads x86_64 for macOS but ABI is detected as arm64).
    cmake_path(NATIVE_PATH DKCODER_HELPERS NORMALIZE DKCODER_HELPERS_NATIVE)
    cmake_path(NATIVE_PATH DKCODER_SHARE NORMALIZE DKCODER_SHARE_NATIVE)
    __dkcoder_add_environment_set("DKCODER_HELPERS=${DKCODER_HELPERS_NATIVE}")
    __dkcoder_add_environment_set("DKCODER_SHARE=${DKCODER_SHARE_NATIVE}")

    # Calculate command line arguments
    set(dkcoder_ARGS)
    foreach(arg IN LISTS "${ARG_ARGUMENT_LIST_VARIABLE}")
        if(CMAKE_HOST_WIN32)
            # escape double-quotes
            string(REPLACE "\"" "\\\"" arg "${arg}")
            string(APPEND dkcoder_ARGS " \"${arg}\"")
        else()
            # replace single quotes with: close string, add escaped single quote, re-open string
            string(REPLACE "'" "'\\''" arg "${arg}")
            string(APPEND dkcoder_ARGS " '${arg}'")
        endif()
    endforeach()

    # Find out which is the entry bytecode executable.
    if(ARG_PACKAGE_NAMESPACE STREQUAL Dk AND ARG_PACKAGE_QUALIFIER STREQUAL Run)
        if(ARG_FULLY_QUALIFIED_MODULE STREQUAL Run)
            set(entryExec "${DKCODER_RUN}")
        else()
            list(GET __DkRun_LTS_VERSIONS -1 __dkrun_v_id) # ie. the latest Vx_y
            message(FATAL_ERROR "Problem: DkCoder only supports the Run entrypoint. Solution: Was there a typo? Try DkRun_${__dkrun_v_id}.Run instead.")
        endif()
    else()
        # If not explicitly a built-in DkCoder entry then use the [Run] entry.
        set(entryExec "${DKCODER_RUN}")
    endif()

    # Write postscript launch script.
    if(CMAKE_HOST_WIN32)
        cmake_path(NATIVE_PATH CMAKE_COMMAND CMAKE_COMMAND_NATIVE)
        cmake_path(NATIVE_PATH DKCODER_OCAMLRUN DKCODER_OCAMLRUN_NATIVE)
        cmake_path(NATIVE_PATH entryExec entryExec_NATIVE)
        file(CONFIGURE OUTPUT "${DKTOOL_POST_SCRIPT}" CONTENT [[REM @ECHO OFF
REM Clear "SET" variables from dk.cmd. They are not part of DkCoder API.
SET DK_7Z_MAJVER=
SET DK_7Z_MINVER=
SET DK_7Z_DOTVER=
SET DK_7Z_VER=
SET DK_CMAKE_VER=
SET DK_NINJA_VER=
SET DK_BUILD_TYPE=
SET DK_SHARE=
SET DK_PROJ_DIR=
SET DK_PWD=
SET DK_CKSUM_7ZR=
SET DK_CKSUM_7ZEXTRA=
SET DK_CKSUM_CMAKE=
SET DK_CKSUM_NINJA=
SET DK_WORKDIR=
SET DK_NONCE=
SET DK_NINJA_EXE=
SET DK_CMDLINE=
SET DK_CMAKE_EXE=

REM Clear variables that influence __dk-find-scripts.cmake. They are not part of DkCoder API.
SET DKRUN_ENV_URL_BASE=

"@CMAKE_COMMAND_NATIVE@" -E env @envMods_DOS@ -- "@DKCODER_OCAMLRUN_NATIVE@" "@entryExec_NATIVE@" @dkcoder_ARGS@
]]
            @ONLY NEWLINE_STYLE DOS)
    else()
        #   + Clear "export" variables from dk
        file(CONFIGURE OUTPUT "${DKTOOL_POST_SCRIPT}" CONTENT [[#!/bin/sh
set -euf
# Clear "export" variables from ./dk. They are not part of DkCoder API.
unset DKMLSYS_MV DKMLSYS_CHMOD DKMLSYS_UNAME DKMLSYS_ENV DKMLSYS_AWK DKMLSYS_SED DKMLSYS_COMM DKMLSYS_INSTALL
unset DKMLSYS_RM DKMLSYS_SORT DKMLSYS_CAT DKMLSYS_STAT DKMLSYS_GREP DKMLSYS_CURL DKMLSYS_WGET DKMLSYS_TR
unset DK_PROG_INSTALLED_LOCATION

# Clear variables that influence __dk-find-scripts.cmake. They are not part of DkCoder API.
unset DKRUN_ENV_URL_BASE

exec '@CMAKE_COMMAND@' -E env @envMods_DOS@ -- '@DKCODER_OCAMLRUN@' '@entryExec@' @dkcoder_ARGS@
]]
            @ONLY NEWLINE_STYLE UNIX)
    endif()
endfunction()

function(__parse_if_ocaml_command)
    set(noValues)
    set(singleValues COMMAND SUCCESS_VARIABLE
        PACKAGE_NAMESPACE_VARIABLE PACKAGE_QUALIFIER_VARIABLE LIBRARY_VARIABLE FULLY_QUALIFIED_MODULE_VARIABLE)
    set(multiValues)
    cmake_parse_arguments(PARSE_ARGV 0 ARG "${noValues}" "${singleValues}" "${multiValues}")

    # Format: PackageName_Libraryname(.Modulename)+
    # Regex: ([A-Z][a-z][a-z0-9]*)([A-Z][A-Za-z0-9]*)_([A-Z][A-Za-z0-9_]*)([.][A-Z]([A-Za-z0-9_]*))+
    # Confer: https://diskuv.com/dksdk/run/2024-intro-scripting/
    string(LENGTH "${ARG_COMMAND}" command_LEN)

    if(command MATCHES "^([A-Z][a-z][a-z0-9]*)([A-Z][A-Za-z0-9]*)_([A-Z][A-Za-z0-9_]*)(([.][A-Z]([A-Za-z0-9_]*))+)$")
        set(${ARG_PACKAGE_NAMESPACE_VARIABLE} "${CMAKE_MATCH_1}" PARENT_SCOPE)
        set(${ARG_PACKAGE_QUALIFIER_VARIABLE} "${CMAKE_MATCH_2}" PARENT_SCOPE)
        set(${ARG_LIBRARY_VARIABLE} "${CMAKE_MATCH_3}" PARENT_SCOPE)
        #   Change .Run to Run
        set(fqn "${CMAKE_MATCH_4}")
        string(REGEX REPLACE "^[.]" "" fqn "${fqn}")
        set(${ARG_FULLY_QUALIFIED_MODULE_VARIABLE} "${fqn}" PARENT_SCOPE)
        set(${ARG_SUCCESS_VARIABLE} ON PARENT_SCOPE)
        return()
    endif()

    set(${ARG_SUCCESS_VARIABLE} OFF PARENT_SCOPE)
endfunction()

function(__parse_dktool_command_line)
    # The first argument is <command>. All dots will be replaced with a
    # triple underscore as a convenience and to be pretty for the user.
    # However, we do not error if no <command> is given ... we'll do
    # that later.
    set(command)
    set(expected_function_name)
    set(quotedArgs "")
    if(ARGC EQUAL 0 OR (ARGC EQUAL 1 AND ARGV0 STREQUAL HELP))
        message(NOTICE [[Usage:
  ./dk <command> HELP
  ./dk <command> [args]

Environment variables:
  DKTOOL_TTL_MINUTES=<n>. How many minutes before updates are fetched.
    Defaults to 60 minutes. Set to 0 to disable caching.
]])
    else()
        set(command ${ARGV0})
        string(REPLACE "." "___" expected_function_name ${command})
        message(VERBOSE "Searching for ${expected_function_name}")

        # Parse the remainder of the arguments [args]
        # * Use technique from [Professional CMake: A Practical Guide - Forwarding Command Arguments]
        #   to be able to forward arguments correctly to an inner function (the <command> function).
        cmake_parse_arguments(PARSE_ARGV 1 FWD "" "" "")
        foreach(arg IN LISTS FWD_UNPARSED_ARGUMENTS)
            string(APPEND quotedArgs " [===[${arg}]===]")
        endforeach()
    endif()

    # Set policies (we are in a new EVAL CODE context)
    #   Included scripts do automatic cmake_policy PUSH and POP
    if(POLICY CMP0011)
        cmake_policy(SET CMP0011 NEW)
    endif()
    #   Allow GIT_SUBMODULES empty to mean no submodules
    if(POLICY CMP0097)
        cmake_policy(SET CMP0097 NEW)
    endif()

    # Setup the binary directory
    if(NOT DKTOOL_WORKDIR)
        message(FATAL_ERROR "Problem: Your `dk` and/or `dk.cmd` are corrupted. Solution: Follow the instructions at https://gitlab.com/diskuv/dktool#installing")
    endif()
    set(CMAKE_BINARY_DIR "${DKTOOL_WORKDIR}")
    set(CMAKE_CURRENT_BINARY_DIR "${CMAKE_BINARY_DIR}")

    # Set a log level used for essentially informational messages
    set(__dktool_log_level STATUS)
    if(DEFINED ENV{DKTOOL_LOGLEVEL} AND (
        "$ENV{DKTOOL_LOGLEVEL_OVERRIDE}" STREQUAL DEBUG OR
        "$ENV{DKTOOL_LOGLEVEL_OVERRIDE}" STREQUAL STATUS))
        set(__dktool_log_level "$ENV{DKTOOL_LOGLEVEL_OVERRIDE}")
    endif()

    # Determine if the <command> is a legacy CMake command or a modern OCaml command
    __parse_if_ocaml_command(COMMAND "${command}"
        SUCCESS_VARIABLE is_ocaml
        PACKAGE_NAMESPACE_VARIABLE package_namespace
        PACKAGE_QUALIFIER_VARIABLE package_qualifier
        LIBRARY_VARIABLE library
        FULLY_QUALIFIED_MODULE_VARIABLE module)
    if(is_ocaml)
        # Get COMPILE_VERSION. Simultaneously recreate the argument list.
        # Argument list:
        #   ./dk DkRun_V0_1.Run DkHelloScript_Std.Example001 1 2 3
        #       ==> [DkHelloScript_Std.Example001 1 2 3]
        #   ./dk DkHelloScript_Std.Example001 1 2 3
        #       ==> [DkHelloScript_Std.Example001 1 2 3]
        #
        #   Is the explicit version specified? That is, DkRun_V0_1.Run (etc.)?
        set(argument_list ${FWD_UNPARSED_ARGUMENTS})
        if(package_namespace STREQUAL "Dk" AND package_qualifier STREQUAL "Run")
            set(__dkrun_v_id "${library}") # ex. V0_1
        else()
            # No it is not DkRun_<Verson>.*. So use the latest LTS version available to this ./dk invocation.
            # The user can upgrade with `./dk dkml.wrapper.upgrade` to get newer versions when they
            # become available.
            list(GET __DkRun_LTS_VERSIONS -1 __dkrun_v_id) # ie. the latest Vx_y
            # Add back in the <command>
            list(PREPEND argument_list ${command})
        endif()
        set(__dkrun_compile_version "${__DkRun_${__dkrun_v_id}_COMPILE_VERSION}")

        # Validation
        if(library STREQUAL "Env" AND NOT DEFINED ENV{DKRUN_ENV_URL_BASE})
            # alert: do not expose unsanitized user-supplied data
            message(FATAL_ERROR "Problem: We want you to use the DKRUN_ENV_URL_BASE environment variable.\n\nSolution: DkSDK subscribers should contact their DkSDK Support representative.")
        elseif(NOT __dkrun_compile_version)
            __dkcoder_error_wrong_version("")
        endif()

        # (Deprecated) Set log level if DkRun_*.ExecQuiet. And then set module from ExecQuiet to Exec.
        if(package_namespace STREQUAL "Dk" AND package_qualifier STREQUAL "Run" AND module STREQUAL "ExecQuiet")
            set(__dktool_log_level DEBUG)
            set(module Exec)
        endif()

        # Set log level if DkRun_*.RunQuiet. And then rename module from RunQuiet to Run.
        if(package_namespace STREQUAL "Dk" AND package_qualifier STREQUAL "Run" AND module STREQUAL "RunQuiet")
            set(__dktool_log_level DEBUG)
            set(module Run)
        endif()

        # Detect ABI
        __dkcoder_abi(ABI_VARIABLE abi)

        # Do DkCoder install
        __dkcoder_install(ABI "${abi}" LOGLEVEL "${__dktool_log_level}" VERSION "${__dkrun_compile_version}")

        # Do DkCoder delegation
        __dkcoder_delegate(
            PACKAGE_NAMESPACE "${package_namespace}"
            PACKAGE_QUALIFIER "${package_qualifier}"
            FULLY_QUALIFIED_MODULE "${module}"
            ARGUMENT_LIST_VARIABLE argument_list)
        return()
    endif()

    # Search in all the (CMake) user scripts
    set(dot_function_names)
    file(GLOB_RECURSE command_files
            LIST_DIRECTORIES FALSE
            RELATIVE ${CMAKE_CURRENT_SOURCE_DIR}/cmake/scripts
            cmake/scripts/*.cmake)
    foreach(command_file IN LISTS command_files)
        # Exclude files and directories that start with: __dk-
        if(command_file MATCHES "(^|/)__dk-")
            continue()
        endif()

        # Normalize and lowercase
        cmake_path(NORMAL_PATH command_file)
        string(TOLOWER "${command_file}" command_file)
        cmake_path(REMOVE_EXTENSION command_file OUTPUT_VARIABLE command_file_no_ext)

        # Convert to list
        string(REPLACE "/" ";" command_stems_no_namespace ${command_file_no_ext})

        # Make a pretty description only for validation
        set(pretty_stems ${command_stems_no_namespace})
        list(TRANSFORM pretty_stems PREPEND "'")
        list(TRANSFORM pretty_stems APPEND "'")
        string(JOIN ", " pretty_stems_str ${pretty_stems})
        string(REGEX REPLACE ",([^,]*)" " and \\1" pretty_stems_str "${pretty_stems_str}")

        # Validate that only alphanumeric with underscores (but not the reserved three underscores)
        string(REGEX MATCH "[/a-z0-9_]*" only_alphanum_and_underscores "${command_file_no_ext}")
        if(NOT only_alphanum_and_underscores STREQUAL "${command_file_no_ext}")
            message(WARNING "Ignoring user script ${CMAKE_CURRENT_SOURCE_DIR}/${command_file}.
The stems of the user script (${pretty_stems_str}) must only contain letters, numbers and underscores.")
            continue()
        endif()
        string(FIND "${command_file_no_ext}" "___" reserved_underscores)
        if(reserved_underscores GREATER_EQUAL 0)
            message(WARNING "Ignoring user script ${CMAKE_CURRENT_SOURCE_DIR}/${command_file}.
No stem of the user script (${pretty_stems_str}) can contain a triple underscore ('___').")
            continue()
        endif()

        # Translate dev/xxx.cmake to the "user" namespaced function name
        # `user__dev__xxx` and `user.dev.xxx`.
        set(command_stems ${command_stems_no_namespace})
        list(PREPEND command_stems "user")
        string(JOIN "___" command_function_name ${command_stems})
        string(JOIN "." dot_function_name ${command_stems})
        list(APPEND dot_function_names ${dot_function_name})

        # In a new scope (to avoid a global, leaky namespace) register the function.
        message(VERBOSE "Shimming ${command_function_name}")
        cmake_language(EVAL CODE "
function(${command_function_name})
    include(\"${CMAKE_CURRENT_SOURCE_DIR}/cmake/scripts/${command_file}\")
    if(COMMAND run)
        run(${quotedArgs})
    else()
        message(FATAL_ERROR [[The user script ${CMAKE_CURRENT_SOURCE_DIR}/cmake/scripts/${command_file} was missing:
  function(run)
    # Your user code
  endfunction()
]])
    endif()
endfunction()
")
    endforeach()

    # Include all the system scripts.
    # - Since the system scripts come after the user scripts, the user scripts
    #   don't override the system scripts unless the user scripts use deferred
    #   hooks or redefine CMake built-in functions. Regardless, the user
    #   scripts are namespaced with `user__` prefix
    if(NOT IS_DIRECTORY cmake/scripts/dksdk)
        # If this project (ex. dktool) has the system scripts, it must
        # have all of them. Otherwise we download the system scripts.
        # But we don't want to download every time we run the script.
        #
        #   The default, but explicit so we know where it is.
        set(dktool_subbuild_dir "${CMAKE_CURRENT_BINARY_DIR}/dktool-subbuild")
        #   Also the default, but explicit since we don't always call FetchContent_Populate().
        set(dktool_src_dir "${CMAKE_CURRENT_BINARY_DIR}/dktool-src")
        #   Prior downloads are fine if done within the last one hour.
        set(ttl_MINUTES 60)
        if(DEFINED ENV{DKTOOL_TTL_MINUTES})
            set(ttl_MINUTES "$ENV{DKTOOL_TTL_MINUTES}")
        endif()
        string(TIMESTAMP now_EPOCHSECS "%s")
        math(EXPR min_valid_EPOCHSECS "${now_EPOCHSECS} - 60*${ttl_MINUTES}")
        set(tstamp_EPOCHSECS 0)
        if(EXISTS "${dktool_subbuild_dir}/build.ninja")
            file(TIMESTAMP "${dktool_subbuild_dir}/build.ninja" tstamp_EPOCHSECS "%s")
        endif()
        if(NOT tstamp_EPOCHSECS OR tstamp_EPOCHSECS LESS_EQUAL min_valid_EPOCHSECS)
            # Cache miss. Time to update dktool.
            FetchContent_Populate(dktool
                QUIET
                SOURCE_DIR "${dktool_src_dir}"
                SUBBUILD_DIR "${dktool_subbuild_dir}"
                GIT_REPOSITORY https://gitlab.com/diskuv/dktool.git
                GIT_TAG 1.0
                # As of 3.25.3 the bug https://gitlab.kitware.com/cmake/cmake/-/issues/24578
                # has still not been fixed. That means empty strings get removed.
                # ExternalProject_Add(GIT_SUBMODULES) in dktool-subbuild/CMakeLists.txt
                # means fetch all submodules.
                # https://gitlab.kitware.com/cmake/cmake/-/issues/20579#note_734045
                # has a workaround.
                GIT_SUBMODULES cmake # Non-git-submodule dir that already exists
                GIT_SUBMODULES_RECURSE OFF)
        endif()
        file(GLOB_RECURSE system_command_files
            LIST_DIRECTORIES FALSE
            RELATIVE ${dktool_src_dir}/cmake/scripts
            ${dktool_src_dir}/cmake/scripts/dkml/*.cmake
            ${dktool_src_dir}/cmake/scripts/dksdk/*.cmake)
        foreach(command_file IN LISTS system_command_files)
            # Normalize and lowercase
            cmake_path(NORMAL_PATH command_file)
            string(TOLOWER "${command_file}" command_file)
            cmake_path(REMOVE_EXTENSION command_file OUTPUT_VARIABLE command_file_no_ext)

            # Convert to list
            string(REPLACE "/" ";" command_stems_no_namespace ${command_file_no_ext})

            # Translate dksdk/xxx.cmake to the function name `dksdk__xxx` and `dksdk.xxx`
            set(command_stems ${command_stems_no_namespace})
            string(JOIN "___" command_function_name ${command_stems})
            string(JOIN "." dot_function_name ${command_stems})
            list(APPEND dot_function_names ${dot_function_name})

            # In a new scope (to avoid a global, leaky namespace) register the function.
            message(VERBOSE "Shimming ${command_function_name}")
            cmake_language(EVAL CODE "
function(${command_function_name})
    include(\"${dktool_src_dir}/cmake/scripts/${command_file}\")
    if(COMMAND run)
        run(${quotedArgs})
    else()
        message(FATAL_ERROR [[The system script ${dktool_src_dir}/cmake/scripts/${command_file} was missing:
  function(run)
    # The system code
  endfunction()
]])
    endif()
endfunction()
")

        endforeach()
    endif()

    # Pretty function names that are available
    set(pretty_function_names ${dot_function_names})
    list(TRANSFORM pretty_function_names PREPEND "  ")
    list(TRANSFORM pretty_function_names APPEND "\n")
    string(JOIN "" str_pretty_function_names ${pretty_function_names})

    # Exit if no <command>
    if(NOT command)
        message(NOTICE "The following commands are available:
${str_pretty_function_names}")
        return()
    endif()

    # Validate the <command> exists
    if(NOT COMMAND ${expected_function_name})
        message(FATAL_ERROR "No command '${command}' exists. The following commands are available:
${str_pretty_function_names}")
        message(FATAL_ERROR "No command '${command}' exists")
    endif()

    # Make space for <command>
    set(CMAKE_CURRENT_BINARY_DIR "${CMAKE_CURRENT_BINARY_DIR}/${expected_function_name}")
    file(MAKE_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}")

    # Call the <command> function
    cmake_language(EVAL CODE "${expected_function_name}()")
endfunction()

# DkSDK data home
if(WIN32)
    set(DKSDK_DATA_HOME "$ENV{LOCALAPPDATA}/Programs/DkSDK")
elseif(DEFINED ENV{XDG_DATA_HOME})
    set(DKSDK_DATA_HOME "$ENV{XDG_DATA_HOME}/dksdk")
else()
    set(DKSDK_DATA_HOME "$ENV{HOME}/.local/share/dksdk")
endif()
cmake_path(NORMAL_PATH DKSDK_DATA_HOME)

# Nonce script
if(CMAKE_HOST_WIN32)
    set(post_script_suffix .cmd)
else()
    set(post_script_suffix .sh)
endif()
cmake_path(APPEND DKTOOL_WORKDIR "${DKTOOL_NONCE}${post_script_suffix}" OUTPUT_VARIABLE DKTOOL_POST_SCRIPT)
cmake_path(NORMAL_PATH DKTOOL_POST_SCRIPT)

# Escape any escape characters before EVAL CODE
string(REPLACE "\\" "\\\\" DKTOOL_CMDLINE "${DKTOOL_CMDLINE}")

# Splat DKTOOL_CMDLINE
cmake_language(EVAL CODE "__parse_dktool_command_line(${DKTOOL_CMDLINE})")
